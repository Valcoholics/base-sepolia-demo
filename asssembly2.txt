function decodePackedData(bytes memory packedData)
    public
    pure
    returns (ICurationLogic.Listing[] memory)
{
    // Calculate the number of listings by dividing the length of packed data by the size of a single listing's data
    uint256 numListings = packedData.length / 46;
    ICurationLogic.Listing[] memory listings = new ICurationLogic.Listing[](numListings);

    // Define a variable to keep track of the current position within the packed data
    uint256 index;

    // Loop through each listing and decode its data
    for (uint256 i = 0; i < numListings; i++) {
        // Read 20 bytes (160 bits) from the current position as the curatedAddress
        // Solidity supports inline assembly to manipulate data at a low level
        assembly {
            // Load 20 bytes from the packed data at the current position
            let curAddr := shr(96, mload(add(add(packedData, 0x20), index)))

            // Store the curatedAddress in the listings array
            mstore(add(add(add(listings, 0x20), mul(i, 0x60)), 0x00), curAddr)
        }

        // Read the next 32 bytes (256 bits) as the selectedTokenId
        uint256 tokenId;
        assembly {
            // Load 32 bytes from the packed data at the current position, offset by 20 bytes
            tokenId := mload(add(add(packedData, 0x20), add(index, 20)))
        }
        listings[i].selectedTokenId = tokenId;

        // Read the next 2 bytes as the curationTargetType and sortOrder, and the next byte as the chainId
        assembly {
            // Load 3 bytes from the packed data at the current position, offset by 52 bytes
            let typeAndOrder := shr(232, mload(add(add(packedData, 0x20), add(index, 52))))

            // Store the curationTargetType (first byte) in the listings array
            mstore8(add(add(add(listings, 0x20), mul(i, 0x60)), 0x26), byte(0, typeAndOrder))

            // Store the sortOrder (second byte) in the listings array
            mstore8(add(add(add(listings, 0x20), mul(i, 0x60)), 0x27), byte(1, typeAndOrder))

            // Store the chainId (third byte) in the listings array
            mstore8(add(add(add(listings, 0x20), mul(i, 0x60)), 0x28), byte(2, typeAndOrder))
        }

        // Read the next byte (8 bits) as a boolean flag for hasTokenId
        assembly {
            // Load 1 byte from the packed data at the current position, offset by 55 bytes
            let hasTokenId := byte(0, mload(add(add(packedData, 0x20), add(index, 55))))

            // Store the hasTokenId (as a boolean) in the listings array
            mstore8(add(add(add(listings, 0x20), mul(i, 0x60)), 0x29), hasTokenId)
        }

        // Update the index to point to the start of the next listing's data
        index += 46;
    }

    return listings